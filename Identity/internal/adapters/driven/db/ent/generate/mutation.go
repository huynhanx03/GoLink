// Code generated by ent, DO NOT EDIT.

package generate

import (
	"context"
	"errors"
	"fmt"
	"go-link/identity/internal/adapters/driven/db/ent/generate/attributedefinition"
	"go-link/identity/internal/adapters/driven/db/ent/generate/credential"
	"go-link/identity/internal/adapters/driven/db/ent/generate/domain"
	"go-link/identity/internal/adapters/driven/db/ent/generate/federatedidentity"
	"go-link/identity/internal/adapters/driven/db/ent/generate/permission"
	"go-link/identity/internal/adapters/driven/db/ent/generate/predicate"
	"go-link/identity/internal/adapters/driven/db/ent/generate/resource"
	"go-link/identity/internal/adapters/driven/db/ent/generate/role"
	"go-link/identity/internal/adapters/driven/db/ent/generate/tenant"
	"go-link/identity/internal/adapters/driven/db/ent/generate/tenantmember"
	"go-link/identity/internal/adapters/driven/db/ent/generate/user"
	"go-link/identity/internal/adapters/driven/db/ent/generate/userattributevalue"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttributeDefinition = "AttributeDefinition"
	TypeCredential          = "Credential"
	TypeDomain              = "Domain"
	TypeFederatedIdentity   = "FederatedIdentity"
	TypePermission          = "Permission"
	TypeResource            = "Resource"
	TypeRole                = "Role"
	TypeTenant              = "Tenant"
	TypeTenantMember        = "TenantMember"
	TypeUser                = "User"
	TypeUserAttributeValue  = "UserAttributeValue"
)

// AttributeDefinitionMutation represents an operation that mutates the AttributeDefinition nodes in the graph.
type AttributeDefinitionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	deleted_by    *int
	adddeleted_by *int
	key           *string
	data_type     *string
	description   *string
	clearedFields map[string]struct{}
	values        map[int]struct{}
	removedvalues map[int]struct{}
	clearedvalues bool
	done          bool
	oldValue      func(context.Context) (*AttributeDefinition, error)
	predicates    []predicate.AttributeDefinition
}

var _ ent.Mutation = (*AttributeDefinitionMutation)(nil)

// attributedefinitionOption allows management of the mutation configuration using functional options.
type attributedefinitionOption func(*AttributeDefinitionMutation)

// newAttributeDefinitionMutation creates new mutation for the AttributeDefinition entity.
func newAttributeDefinitionMutation(c config, op Op, opts ...attributedefinitionOption) *AttributeDefinitionMutation {
	m := &AttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeDefinitionID sets the ID field of the mutation.
func withAttributeDefinitionID(id int) attributedefinitionOption {
	return func(m *AttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *AttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*AttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttributeDefinition sets the old AttributeDefinition of the mutation.
func withAttributeDefinition(node *AttributeDefinition) attributedefinitionOption {
	return func(m *AttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*AttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttributeDefinitionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttributeDefinitionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttributeDefinitionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attributedefinition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttributeDefinitionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attributedefinition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttributeDefinitionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attributedefinition.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AttributeDefinitionMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AttributeDefinitionMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AttributeDefinitionMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AttributeDefinitionMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AttributeDefinitionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[attributedefinition.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AttributeDefinitionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[attributedefinition.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AttributeDefinitionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, attributedefinition.FieldDeletedBy)
}

// SetKey sets the "key" field.
func (m *AttributeDefinitionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *AttributeDefinitionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AttributeDefinitionMutation) ResetKey() {
	m.key = nil
}

// SetDataType sets the "data_type" field.
func (m *AttributeDefinitionMutation) SetDataType(s string) {
	m.data_type = &s
}

// DataType returns the value of the "data_type" field in the mutation.
func (m *AttributeDefinitionMutation) DataType() (r string, exists bool) {
	v := m.data_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDataType returns the old "data_type" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldDataType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataType: %w", err)
	}
	return oldValue.DataType, nil
}

// ResetDataType resets all changes to the "data_type" field.
func (m *AttributeDefinitionMutation) ResetDataType() {
	m.data_type = nil
}

// SetDescription sets the "description" field.
func (m *AttributeDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AttributeDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AttributeDefinition entity.
// If the AttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AttributeDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[attributedefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AttributeDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[attributedefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AttributeDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, attributedefinition.FieldDescription)
}

// AddValueIDs adds the "values" edge to the UserAttributeValue entity by ids.
func (m *AttributeDefinitionMutation) AddValueIDs(ids ...int) {
	if m.values == nil {
		m.values = make(map[int]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the UserAttributeValue entity.
func (m *AttributeDefinitionMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the UserAttributeValue entity was cleared.
func (m *AttributeDefinitionMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the UserAttributeValue entity by IDs.
func (m *AttributeDefinitionMutation) RemoveValueIDs(ids ...int) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the UserAttributeValue entity.
func (m *AttributeDefinitionMutation) RemovedValuesIDs() (ids []int) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *AttributeDefinitionMutation) ValuesIDs() (ids []int) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *AttributeDefinitionMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the AttributeDefinitionMutation builder.
func (m *AttributeDefinitionMutation) Where(ps ...predicate.AttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttributeDefinition).
func (m *AttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attributedefinition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attributedefinition.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, attributedefinition.FieldDeletedBy)
	}
	if m.key != nil {
		fields = append(fields, attributedefinition.FieldKey)
	}
	if m.data_type != nil {
		fields = append(fields, attributedefinition.FieldDataType)
	}
	if m.description != nil {
		fields = append(fields, attributedefinition.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case attributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	case attributedefinition.FieldDeletedAt:
		return m.DeletedAt()
	case attributedefinition.FieldDeletedBy:
		return m.DeletedBy()
	case attributedefinition.FieldKey:
		return m.Key()
	case attributedefinition.FieldDataType:
		return m.DataType()
	case attributedefinition.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attributedefinition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attributedefinition.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case attributedefinition.FieldKey:
		return m.OldKey(ctx)
	case attributedefinition.FieldDataType:
		return m.OldDataType(ctx)
	case attributedefinition.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attributedefinition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attributedefinition.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case attributedefinition.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case attributedefinition.FieldDataType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataType(v)
		return nil
	case attributedefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, attributedefinition.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attributedefinition.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attributedefinition.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attributedefinition.FieldDeletedAt) {
		fields = append(fields, attributedefinition.FieldDeletedAt)
	}
	if m.FieldCleared(attributedefinition.FieldDeletedBy) {
		fields = append(fields, attributedefinition.FieldDeletedBy)
	}
	if m.FieldCleared(attributedefinition.FieldDescription) {
		fields = append(fields, attributedefinition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case attributedefinition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attributedefinition.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case attributedefinition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case attributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attributedefinition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attributedefinition.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case attributedefinition.FieldKey:
		m.ResetKey()
		return nil
	case attributedefinition.FieldDataType:
		m.ResetDataType()
		return nil
	case attributedefinition.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.values != nil {
		edges = append(edges, attributedefinition.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalues != nil {
		edges = append(edges, attributedefinition.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalues {
		edges = append(edges, attributedefinition.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case attributedefinition.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeDefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case attributedefinition.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown AttributeDefinition edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	deleted_by      *int
	adddeleted_by   *int
	_type           *string
	credential_data *map[string]interface{}
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Credential, error)
	predicates      []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[credential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, credential.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *CredentialMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *CredentialMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *CredentialMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *CredentialMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *CredentialMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[credential.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *CredentialMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *CredentialMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, credential.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *CredentialMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CredentialMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CredentialMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *CredentialMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CredentialMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CredentialMutation) ResetType() {
	m._type = nil
}

// SetCredentialData sets the "credential_data" field.
func (m *CredentialMutation) SetCredentialData(value map[string]interface{}) {
	m.credential_data = &value
}

// CredentialData returns the value of the "credential_data" field in the mutation.
func (m *CredentialMutation) CredentialData() (r map[string]interface{}, exists bool) {
	v := m.credential_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialData returns the old "credential_data" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCredentialData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialData: %w", err)
	}
	return oldValue.CredentialData, nil
}

// ResetCredentialData resets all changes to the "credential_data" field.
func (m *CredentialMutation) ResetCredentialData() {
	m.credential_data = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CredentialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[credential.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, credential.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, credential.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, credential.FieldType)
	}
	if m.credential_data != nil {
		fields = append(fields, credential.FieldCredentialData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldDeletedAt:
		return m.DeletedAt()
	case credential.FieldDeletedBy:
		return m.DeletedBy()
	case credential.FieldUserID:
		return m.UserID()
	case credential.FieldType:
		return m.GetType()
	case credential.FieldCredentialData:
		return m.CredentialData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case credential.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case credential.FieldUserID:
		return m.OldUserID(ctx)
	case credential.FieldType:
		return m.OldType(ctx)
	case credential.FieldCredentialData:
		return m.OldCredentialData(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case credential.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case credential.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credential.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case credential.FieldCredentialData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialData(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, credential.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credential.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldDeletedAt) {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.FieldCleared(credential.FieldDeletedBy) {
		fields = append(fields, credential.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case credential.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case credential.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case credential.FieldUserID:
		m.ResetUserID()
		return nil
	case credential.FieldType:
		m.ResetType()
		return nil
	case credential.FieldCredentialData:
		m.ResetCredentialData()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DomainMutation represents an operation that mutates the Domain nodes in the graph.
type DomainMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	deleted_by    *int
	adddeleted_by *int
	domain        *string
	is_verified   *bool
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Domain, error)
	predicates    []predicate.Domain
}

var _ ent.Mutation = (*DomainMutation)(nil)

// domainOption allows management of the mutation configuration using functional options.
type domainOption func(*DomainMutation)

// newDomainMutation creates new mutation for the Domain entity.
func newDomainMutation(c config, op Op, opts ...domainOption) *DomainMutation {
	m := &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainID sets the ID field of the mutation.
func withDomainID(id int) domainOption {
	return func(m *DomainMutation) {
		var (
			err   error
			once  sync.Once
			value *Domain
		)
		m.oldValue = func(ctx context.Context) (*Domain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Domain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomain sets the old Domain of the mutation.
func withDomain(node *Domain) domainOption {
	return func(m *DomainMutation) {
		m.oldValue = func(context.Context) (*Domain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Domain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DomainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DomainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DomainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DomainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DomainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DomainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DomainMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DomainMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DomainMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[domain.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DomainMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[domain.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DomainMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, domain.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DomainMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DomainMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *DomainMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *DomainMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DomainMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[domain.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DomainMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[domain.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DomainMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, domain.FieldDeletedBy)
}

// SetDomain sets the "domain" field.
func (m *DomainMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *DomainMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *DomainMutation) ResetDomain() {
	m.domain = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *DomainMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DomainMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DomainMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *DomainMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *DomainMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *DomainMutation) ResetIsVerified() {
	m.is_verified = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DomainMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[domain.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DomainMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DomainMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DomainMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the DomainMutation builder.
func (m *DomainMutation) Where(ps ...predicate.Domain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Domain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, domain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, domain.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, domain.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, domain.FieldDeletedBy)
	}
	if m.domain != nil {
		fields = append(fields, domain.FieldDomain)
	}
	if m.tenant != nil {
		fields = append(fields, domain.FieldTenantID)
	}
	if m.is_verified != nil {
		fields = append(fields, domain.FieldIsVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldCreatedAt:
		return m.CreatedAt()
	case domain.FieldUpdatedAt:
		return m.UpdatedAt()
	case domain.FieldDeletedAt:
		return m.DeletedAt()
	case domain.FieldDeletedBy:
		return m.DeletedBy()
	case domain.FieldDomain:
		return m.Domain()
	case domain.FieldTenantID:
		return m.TenantID()
	case domain.FieldIsVerified:
		return m.IsVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case domain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case domain.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case domain.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case domain.FieldDomain:
		return m.OldDomain(ctx)
	case domain.FieldTenantID:
		return m.OldTenantID(ctx)
	case domain.FieldIsVerified:
		return m.OldIsVerified(ctx)
	}
	return nil, fmt.Errorf("unknown Domain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case domain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case domain.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case domain.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case domain.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case domain.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case domain.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, domain.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case domain.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(domain.FieldDeletedAt) {
		fields = append(fields, domain.FieldDeletedAt)
	}
	if m.FieldCleared(domain.FieldDeletedBy) {
		fields = append(fields, domain.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	switch name {
	case domain.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case domain.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case domain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case domain.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case domain.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case domain.FieldDomain:
		m.ResetDomain()
		return nil
	case domain.FieldTenantID:
		m.ResetTenantID()
		return nil
	case domain.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, domain.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, domain.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	case domain.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	case domain.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// FederatedIdentityMutation represents an operation that mutates the FederatedIdentity nodes in the graph.
type FederatedIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	deleted_by    *int
	adddeleted_by *int
	provider      *string
	external_id   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*FederatedIdentity, error)
	predicates    []predicate.FederatedIdentity
}

var _ ent.Mutation = (*FederatedIdentityMutation)(nil)

// federatedidentityOption allows management of the mutation configuration using functional options.
type federatedidentityOption func(*FederatedIdentityMutation)

// newFederatedIdentityMutation creates new mutation for the FederatedIdentity entity.
func newFederatedIdentityMutation(c config, op Op, opts ...federatedidentityOption) *FederatedIdentityMutation {
	m := &FederatedIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeFederatedIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFederatedIdentityID sets the ID field of the mutation.
func withFederatedIdentityID(id int) federatedidentityOption {
	return func(m *FederatedIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *FederatedIdentity
		)
		m.oldValue = func(ctx context.Context) (*FederatedIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FederatedIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFederatedIdentity sets the old FederatedIdentity of the mutation.
func withFederatedIdentity(node *FederatedIdentity) federatedidentityOption {
	return func(m *FederatedIdentityMutation) {
		m.oldValue = func(context.Context) (*FederatedIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FederatedIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FederatedIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FederatedIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FederatedIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FederatedIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FederatedIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FederatedIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FederatedIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FederatedIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FederatedIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FederatedIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FederatedIdentityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FederatedIdentityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FederatedIdentityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[federatedidentity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FederatedIdentityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[federatedidentity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FederatedIdentityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, federatedidentity.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FederatedIdentityMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FederatedIdentityMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *FederatedIdentityMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *FederatedIdentityMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FederatedIdentityMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[federatedidentity.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FederatedIdentityMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[federatedidentity.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FederatedIdentityMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, federatedidentity.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *FederatedIdentityMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FederatedIdentityMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FederatedIdentityMutation) ResetUserID() {
	m.user = nil
}

// SetProvider sets the "provider" field.
func (m *FederatedIdentityMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *FederatedIdentityMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *FederatedIdentityMutation) ResetProvider() {
	m.provider = nil
}

// SetExternalID sets the "external_id" field.
func (m *FederatedIdentityMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *FederatedIdentityMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the FederatedIdentity entity.
// If the FederatedIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FederatedIdentityMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *FederatedIdentityMutation) ResetExternalID() {
	m.external_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FederatedIdentityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[federatedidentity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FederatedIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FederatedIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FederatedIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the FederatedIdentityMutation builder.
func (m *FederatedIdentityMutation) Where(ps ...predicate.FederatedIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FederatedIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FederatedIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FederatedIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FederatedIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FederatedIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FederatedIdentity).
func (m *FederatedIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FederatedIdentityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, federatedidentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, federatedidentity.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, federatedidentity.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, federatedidentity.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, federatedidentity.FieldUserID)
	}
	if m.provider != nil {
		fields = append(fields, federatedidentity.FieldProvider)
	}
	if m.external_id != nil {
		fields = append(fields, federatedidentity.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FederatedIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case federatedidentity.FieldCreatedAt:
		return m.CreatedAt()
	case federatedidentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case federatedidentity.FieldDeletedAt:
		return m.DeletedAt()
	case federatedidentity.FieldDeletedBy:
		return m.DeletedBy()
	case federatedidentity.FieldUserID:
		return m.UserID()
	case federatedidentity.FieldProvider:
		return m.Provider()
	case federatedidentity.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FederatedIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case federatedidentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case federatedidentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case federatedidentity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case federatedidentity.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case federatedidentity.FieldUserID:
		return m.OldUserID(ctx)
	case federatedidentity.FieldProvider:
		return m.OldProvider(ctx)
	case federatedidentity.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown FederatedIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FederatedIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case federatedidentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case federatedidentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case federatedidentity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case federatedidentity.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case federatedidentity.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case federatedidentity.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case federatedidentity.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FederatedIdentityMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, federatedidentity.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FederatedIdentityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case federatedidentity.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FederatedIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case federatedidentity.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FederatedIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(federatedidentity.FieldDeletedAt) {
		fields = append(fields, federatedidentity.FieldDeletedAt)
	}
	if m.FieldCleared(federatedidentity.FieldDeletedBy) {
		fields = append(fields, federatedidentity.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FederatedIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FederatedIdentityMutation) ClearField(name string) error {
	switch name {
	case federatedidentity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case federatedidentity.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FederatedIdentityMutation) ResetField(name string) error {
	switch name {
	case federatedidentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case federatedidentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case federatedidentity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case federatedidentity.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case federatedidentity.FieldUserID:
		m.ResetUserID()
		return nil
	case federatedidentity.FieldProvider:
		m.ResetProvider()
		return nil
	case federatedidentity.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FederatedIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, federatedidentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FederatedIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case federatedidentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FederatedIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FederatedIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FederatedIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, federatedidentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FederatedIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case federatedidentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FederatedIdentityMutation) ClearEdge(name string) error {
	switch name {
	case federatedidentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FederatedIdentityMutation) ResetEdge(name string) error {
	switch name {
	case federatedidentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown FederatedIdentity edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	deleted_by      *int
	adddeleted_by   *int
	description     *string
	scopes          *int
	addscopes       *int
	clearedFields   map[string]struct{}
	role            *int
	clearedrole     bool
	resource        *int
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*Permission, error)
	predicates      []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PermissionMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PermissionMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *PermissionMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *PermissionMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PermissionMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[permission.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PermissionMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PermissionMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, permission.FieldDeletedBy)
}

// SetRoleID sets the "role_id" field.
func (m *PermissionMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *PermissionMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *PermissionMutation) ResetRoleID() {
	m.role = nil
}

// SetResourceID sets the "resource_id" field.
func (m *PermissionMutation) SetResourceID(i int) {
	m.resource = &i
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *PermissionMutation) ResourceID() (r int, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *PermissionMutation) ResetResourceID() {
	m.resource = nil
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[permission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, permission.FieldDescription)
}

// SetScopes sets the "scopes" field.
func (m *PermissionMutation) SetScopes(i int) {
	m.scopes = &i
	m.addscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *PermissionMutation) Scopes() (r int, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldScopes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AddScopes adds i to the "scopes" field.
func (m *PermissionMutation) AddScopes(i int) {
	if m.addscopes != nil {
		*m.addscopes += i
	} else {
		m.addscopes = &i
	}
}

// AddedScopes returns the value that was added to the "scopes" field in this mutation.
func (m *PermissionMutation) AddedScopes() (r int, exists bool) {
	v := m.addscopes
	if v == nil {
		return
	}
	return *v, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *PermissionMutation) ResetScopes() {
	m.scopes = nil
	m.addscopes = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *PermissionMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[permission.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *PermissionMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *PermissionMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[permission.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *PermissionMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *PermissionMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.role != nil {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.resource != nil {
		fields = append(fields, permission.FieldResourceID)
	}
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	if m.scopes != nil {
		fields = append(fields, permission.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldDeletedBy:
		return m.DeletedBy()
	case permission.FieldRoleID:
		return m.RoleID()
	case permission.FieldResourceID:
		return m.ResourceID()
	case permission.FieldDescription:
		return m.Description()
	case permission.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case permission.FieldRoleID:
		return m.OldRoleID(ctx)
	case permission.FieldResourceID:
		return m.OldResourceID(ctx)
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	case permission.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case permission.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case permission.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case permission.FieldScopes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.addscopes != nil {
		fields = append(fields, permission.FieldScopes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldDeletedBy:
		return m.AddedDeletedBy()
	case permission.FieldScopes:
		return m.AddedScopes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case permission.FieldScopes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldDeletedBy) {
		fields = append(fields, permission.FieldDeletedBy)
	}
	if m.FieldCleared(permission.FieldDescription) {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case permission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case permission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case permission.FieldResourceID:
		m.ResetResourceID()
		return nil
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	case permission.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, permission.EdgeRole)
	}
	if m.resource != nil {
		edges = append(edges, permission.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, permission.EdgeRole)
	}
	if m.clearedresource {
		edges = append(edges, permission.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRole:
		return m.clearedrole
	case permission.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeRole:
		m.ClearRole()
		return nil
	case permission.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRole:
		m.ResetRole()
		return nil
	case permission.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	deleted_by         *int
	adddeleted_by      *int
	key                *string
	description        *string
	clearedFields      map[string]struct{}
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
	predicates         []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResourceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResourceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResourceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resource.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResourceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resource.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResourceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resource.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ResourceMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ResourceMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *ResourceMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *ResourceMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ResourceMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[resource.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ResourceMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[resource.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ResourceMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, resource.FieldDeletedBy)
}

// SetKey sets the "key" field.
func (m *ResourceMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ResourceMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ResourceMutation) ResetKey() {
	m.key = nil
}

// SetDescription sets the "description" field.
func (m *ResourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResourceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resource.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResourceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resource.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resource.FieldDescription)
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *ResourceMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *ResourceMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *ResourceMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *ResourceMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *ResourceMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *ResourceMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *ResourceMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, resource.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, resource.FieldDeletedBy)
	}
	if m.key != nil {
		fields = append(fields, resource.FieldKey)
	}
	if m.description != nil {
		fields = append(fields, resource.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldDeletedAt:
		return m.DeletedAt()
	case resource.FieldDeletedBy:
		return m.DeletedBy()
	case resource.FieldKey:
		return m.Key()
	case resource.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resource.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case resource.FieldKey:
		return m.OldKey(ctx)
	case resource.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resource.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case resource.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case resource.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, resource.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resource.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldDeletedAt) {
		fields = append(fields, resource.FieldDeletedAt)
	}
	if m.FieldCleared(resource.FieldDeletedBy) {
		fields = append(fields, resource.FieldDeletedBy)
	}
	if m.FieldCleared(resource.FieldDescription) {
		fields = append(fields, resource.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resource.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case resource.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resource.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case resource.FieldKey:
		m.ResetKey()
		return nil
	case resource.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.permissions != nil {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpermissions != nil {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpermissions {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	deleted_by            *int
	adddeleted_by         *int
	name                  *string
	level                 *int
	addlevel              *int
	parent_id             *int
	addparent_id          *int
	lft                   *int
	addlft                *int
	rgt                   *int
	addrgt                *int
	clearedFields         map[string]struct{}
	tenant_members        map[int]struct{}
	removedtenant_members map[int]struct{}
	clearedtenant_members bool
	permissions           map[int]struct{}
	removedpermissions    map[int]struct{}
	clearedpermissions    bool
	done                  bool
	oldValue              func(context.Context) (*Role, error)
	predicates            []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RoleMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RoleMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *RoleMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *RoleMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RoleMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[role.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RoleMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RoleMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, role.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *RoleMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *RoleMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *RoleMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *RoleMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *RoleMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetParentID sets the "parent_id" field.
func (m *RoleMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *RoleMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *RoleMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *RoleMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *RoleMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetLft sets the "lft" field.
func (m *RoleMutation) SetLft(i int) {
	m.lft = &i
	m.addlft = nil
}

// Lft returns the value of the "lft" field in the mutation.
func (m *RoleMutation) Lft() (r int, exists bool) {
	v := m.lft
	if v == nil {
		return
	}
	return *v, true
}

// OldLft returns the old "lft" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLft(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLft: %w", err)
	}
	return oldValue.Lft, nil
}

// AddLft adds i to the "lft" field.
func (m *RoleMutation) AddLft(i int) {
	if m.addlft != nil {
		*m.addlft += i
	} else {
		m.addlft = &i
	}
}

// AddedLft returns the value that was added to the "lft" field in this mutation.
func (m *RoleMutation) AddedLft() (r int, exists bool) {
	v := m.addlft
	if v == nil {
		return
	}
	return *v, true
}

// ResetLft resets all changes to the "lft" field.
func (m *RoleMutation) ResetLft() {
	m.lft = nil
	m.addlft = nil
}

// SetRgt sets the "rgt" field.
func (m *RoleMutation) SetRgt(i int) {
	m.rgt = &i
	m.addrgt = nil
}

// Rgt returns the value of the "rgt" field in the mutation.
func (m *RoleMutation) Rgt() (r int, exists bool) {
	v := m.rgt
	if v == nil {
		return
	}
	return *v, true
}

// OldRgt returns the old "rgt" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRgt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRgt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRgt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRgt: %w", err)
	}
	return oldValue.Rgt, nil
}

// AddRgt adds i to the "rgt" field.
func (m *RoleMutation) AddRgt(i int) {
	if m.addrgt != nil {
		*m.addrgt += i
	} else {
		m.addrgt = &i
	}
}

// AddedRgt returns the value that was added to the "rgt" field in this mutation.
func (m *RoleMutation) AddedRgt() (r int, exists bool) {
	v := m.addrgt
	if v == nil {
		return
	}
	return *v, true
}

// ResetRgt resets all changes to the "rgt" field.
func (m *RoleMutation) ResetRgt() {
	m.rgt = nil
	m.addrgt = nil
}

// AddTenantMemberIDs adds the "tenant_members" edge to the TenantMember entity by ids.
func (m *RoleMutation) AddTenantMemberIDs(ids ...int) {
	if m.tenant_members == nil {
		m.tenant_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tenant_members[ids[i]] = struct{}{}
	}
}

// ClearTenantMembers clears the "tenant_members" edge to the TenantMember entity.
func (m *RoleMutation) ClearTenantMembers() {
	m.clearedtenant_members = true
}

// TenantMembersCleared reports if the "tenant_members" edge to the TenantMember entity was cleared.
func (m *RoleMutation) TenantMembersCleared() bool {
	return m.clearedtenant_members
}

// RemoveTenantMemberIDs removes the "tenant_members" edge to the TenantMember entity by IDs.
func (m *RoleMutation) RemoveTenantMemberIDs(ids ...int) {
	if m.removedtenant_members == nil {
		m.removedtenant_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tenant_members, ids[i])
		m.removedtenant_members[ids[i]] = struct{}{}
	}
}

// RemovedTenantMembers returns the removed IDs of the "tenant_members" edge to the TenantMember entity.
func (m *RoleMutation) RemovedTenantMembersIDs() (ids []int) {
	for id := range m.removedtenant_members {
		ids = append(ids, id)
	}
	return
}

// TenantMembersIDs returns the "tenant_members" edge IDs in the mutation.
func (m *RoleMutation) TenantMembersIDs() (ids []int) {
	for id := range m.tenant_members {
		ids = append(ids, id)
	}
	return
}

// ResetTenantMembers resets all changes to the "tenant_members" edge.
func (m *RoleMutation) ResetTenantMembers() {
	m.tenant_members = nil
	m.clearedtenant_members = false
	m.removedtenant_members = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.level != nil {
		fields = append(fields, role.FieldLevel)
	}
	if m.parent_id != nil {
		fields = append(fields, role.FieldParentID)
	}
	if m.lft != nil {
		fields = append(fields, role.FieldLft)
	}
	if m.rgt != nil {
		fields = append(fields, role.FieldRgt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldDeletedBy:
		return m.DeletedBy()
	case role.FieldName:
		return m.Name()
	case role.FieldLevel:
		return m.Level()
	case role.FieldParentID:
		return m.ParentID()
	case role.FieldLft:
		return m.Lft()
	case role.FieldRgt:
		return m.Rgt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldLevel:
		return m.OldLevel(ctx)
	case role.FieldParentID:
		return m.OldParentID(ctx)
	case role.FieldLft:
		return m.OldLft(ctx)
	case role.FieldRgt:
		return m.OldRgt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case role.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case role.FieldLft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLft(v)
		return nil
	case role.FieldRgt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRgt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, role.FieldDeletedBy)
	}
	if m.addlevel != nil {
		fields = append(fields, role.FieldLevel)
	}
	if m.addparent_id != nil {
		fields = append(fields, role.FieldParentID)
	}
	if m.addlft != nil {
		fields = append(fields, role.FieldLft)
	}
	if m.addrgt != nil {
		fields = append(fields, role.FieldRgt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedBy:
		return m.AddedDeletedBy()
	case role.FieldLevel:
		return m.AddedLevel()
	case role.FieldParentID:
		return m.AddedParentID()
	case role.FieldLft:
		return m.AddedLft()
	case role.FieldRgt:
		return m.AddedRgt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case role.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case role.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case role.FieldLft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLft(v)
		return nil
	case role.FieldRgt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRgt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldDeletedBy) {
		fields = append(fields, role.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldLevel:
		m.ResetLevel()
		return nil
	case role.FieldParentID:
		m.ResetParentID()
		return nil
	case role.FieldLft:
		m.ResetLft()
		return nil
	case role.FieldRgt:
		m.ResetRgt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant_members != nil {
		edges = append(edges, role.EdgeTenantMembers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.tenant_members))
		for id := range m.tenant_members {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtenant_members != nil {
		edges = append(edges, role.EdgeTenantMembers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.removedtenant_members))
		for id := range m.removedtenant_members {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant_members {
		edges = append(edges, role.EdgeTenantMembers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeTenantMembers:
		return m.clearedtenant_members
	case role.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeTenantMembers:
		m.ResetTenantMembers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	deleted_by            *int
	adddeleted_by         *int
	name                  *string
	tier_id               *int
	addtier_id            *int
	clearedFields         map[string]struct{}
	tenant_members        map[int]struct{}
	removedtenant_members map[int]struct{}
	clearedtenant_members bool
	domains               map[int]struct{}
	removeddomains        map[int]struct{}
	cleareddomains        bool
	done                  bool
	oldValue              func(context.Context) (*Tenant, error)
	predicates            []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TenantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TenantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TenantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tenant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TenantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TenantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tenant.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TenantMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TenantMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TenantMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TenantMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TenantMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[tenant.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TenantMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TenantMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, tenant.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetTierID sets the "tier_id" field.
func (m *TenantMutation) SetTierID(i int) {
	m.tier_id = &i
	m.addtier_id = nil
}

// TierID returns the value of the "tier_id" field in the mutation.
func (m *TenantMutation) TierID() (r int, exists bool) {
	v := m.tier_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTierID returns the old "tier_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTierID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTierID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTierID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTierID: %w", err)
	}
	return oldValue.TierID, nil
}

// AddTierID adds i to the "tier_id" field.
func (m *TenantMutation) AddTierID(i int) {
	if m.addtier_id != nil {
		*m.addtier_id += i
	} else {
		m.addtier_id = &i
	}
}

// AddedTierID returns the value that was added to the "tier_id" field in this mutation.
func (m *TenantMutation) AddedTierID() (r int, exists bool) {
	v := m.addtier_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTierID resets all changes to the "tier_id" field.
func (m *TenantMutation) ResetTierID() {
	m.tier_id = nil
	m.addtier_id = nil
}

// AddTenantMemberIDs adds the "tenant_members" edge to the TenantMember entity by ids.
func (m *TenantMutation) AddTenantMemberIDs(ids ...int) {
	if m.tenant_members == nil {
		m.tenant_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tenant_members[ids[i]] = struct{}{}
	}
}

// ClearTenantMembers clears the "tenant_members" edge to the TenantMember entity.
func (m *TenantMutation) ClearTenantMembers() {
	m.clearedtenant_members = true
}

// TenantMembersCleared reports if the "tenant_members" edge to the TenantMember entity was cleared.
func (m *TenantMutation) TenantMembersCleared() bool {
	return m.clearedtenant_members
}

// RemoveTenantMemberIDs removes the "tenant_members" edge to the TenantMember entity by IDs.
func (m *TenantMutation) RemoveTenantMemberIDs(ids ...int) {
	if m.removedtenant_members == nil {
		m.removedtenant_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tenant_members, ids[i])
		m.removedtenant_members[ids[i]] = struct{}{}
	}
}

// RemovedTenantMembers returns the removed IDs of the "tenant_members" edge to the TenantMember entity.
func (m *TenantMutation) RemovedTenantMembersIDs() (ids []int) {
	for id := range m.removedtenant_members {
		ids = append(ids, id)
	}
	return
}

// TenantMembersIDs returns the "tenant_members" edge IDs in the mutation.
func (m *TenantMutation) TenantMembersIDs() (ids []int) {
	for id := range m.tenant_members {
		ids = append(ids, id)
	}
	return
}

// ResetTenantMembers resets all changes to the "tenant_members" edge.
func (m *TenantMutation) ResetTenantMembers() {
	m.tenant_members = nil
	m.clearedtenant_members = false
	m.removedtenant_members = nil
}

// AddDomainIDs adds the "domains" edge to the Domain entity by ids.
func (m *TenantMutation) AddDomainIDs(ids ...int) {
	if m.domains == nil {
		m.domains = make(map[int]struct{})
	}
	for i := range ids {
		m.domains[ids[i]] = struct{}{}
	}
}

// ClearDomains clears the "domains" edge to the Domain entity.
func (m *TenantMutation) ClearDomains() {
	m.cleareddomains = true
}

// DomainsCleared reports if the "domains" edge to the Domain entity was cleared.
func (m *TenantMutation) DomainsCleared() bool {
	return m.cleareddomains
}

// RemoveDomainIDs removes the "domains" edge to the Domain entity by IDs.
func (m *TenantMutation) RemoveDomainIDs(ids ...int) {
	if m.removeddomains == nil {
		m.removeddomains = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.domains, ids[i])
		m.removeddomains[ids[i]] = struct{}{}
	}
}

// RemovedDomains returns the removed IDs of the "domains" edge to the Domain entity.
func (m *TenantMutation) RemovedDomainsIDs() (ids []int) {
	for id := range m.removeddomains {
		ids = append(ids, id)
	}
	return
}

// DomainsIDs returns the "domains" edge IDs in the mutation.
func (m *TenantMutation) DomainsIDs() (ids []int) {
	for id := range m.domains {
		ids = append(ids, id)
	}
	return
}

// ResetDomains resets all changes to the "domains" edge.
func (m *TenantMutation) ResetDomains() {
	m.domains = nil
	m.cleareddomains = false
	m.removeddomains = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.tier_id != nil {
		fields = append(fields, tenant.FieldTierID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenant.FieldDeletedAt:
		return m.DeletedAt()
	case tenant.FieldDeletedBy:
		return m.DeletedBy()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldTierID:
		return m.TierID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tenant.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldTierID:
		return m.OldTierID(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tenant.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldTierID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTierID(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.addtier_id != nil {
		fields = append(fields, tenant.FieldTierID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldDeletedBy:
		return m.AddedDeletedBy()
	case tenant.FieldTierID:
		return m.AddedTierID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case tenant.FieldTierID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTierID(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDeletedAt) {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.FieldCleared(tenant.FieldDeletedBy) {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tenant.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tenant.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldTierID:
		m.ResetTierID()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant_members != nil {
		edges = append(edges, tenant.EdgeTenantMembers)
	}
	if m.domains != nil {
		edges = append(edges, tenant.EdgeDomains)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.tenant_members))
		for id := range m.tenant_members {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.domains))
		for id := range m.domains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtenant_members != nil {
		edges = append(edges, tenant.EdgeTenantMembers)
	}
	if m.removeddomains != nil {
		edges = append(edges, tenant.EdgeDomains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.removedtenant_members))
		for id := range m.removedtenant_members {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.removeddomains))
		for id := range m.removeddomains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant_members {
		edges = append(edges, tenant.EdgeTenantMembers)
	}
	if m.cleareddomains {
		edges = append(edges, tenant.EdgeDomains)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeTenantMembers:
		return m.clearedtenant_members
	case tenant.EdgeDomains:
		return m.cleareddomains
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeTenantMembers:
		m.ResetTenantMembers()
		return nil
	case tenant.EdgeDomains:
		m.ResetDomains()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TenantMemberMutation represents an operation that mutates the TenantMember nodes in the graph.
type TenantMemberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	deleted_by    *int
	adddeleted_by *int
	clearedFields map[string]struct{}
	tenant        *int
	clearedtenant bool
	user          *int
	cleareduser   bool
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*TenantMember, error)
	predicates    []predicate.TenantMember
}

var _ ent.Mutation = (*TenantMemberMutation)(nil)

// tenantmemberOption allows management of the mutation configuration using functional options.
type tenantmemberOption func(*TenantMemberMutation)

// newTenantMemberMutation creates new mutation for the TenantMember entity.
func newTenantMemberMutation(c config, op Op, opts ...tenantmemberOption) *TenantMemberMutation {
	m := &TenantMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantMemberID sets the ID field of the mutation.
func withTenantMemberID(id int) tenantmemberOption {
	return func(m *TenantMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantMember
		)
		m.oldValue = func(ctx context.Context) (*TenantMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantMember sets the old TenantMember of the mutation.
func withTenantMember(node *TenantMember) tenantmemberOption {
	return func(m *TenantMemberMutation) {
		m.oldValue = func(context.Context) (*TenantMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TenantMemberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TenantMemberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TenantMemberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tenantmember.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TenantMemberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tenantmember.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TenantMemberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tenantmember.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TenantMemberMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TenantMemberMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *TenantMemberMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TenantMemberMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TenantMemberMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[tenantmember.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TenantMemberMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tenantmember.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TenantMemberMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, tenantmember.FieldDeletedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantMemberMutation) SetTenantID(i int) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantMemberMutation) TenantID() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantMemberMutation) ResetTenantID() {
	m.tenant = nil
}

// SetUserID sets the "user_id" field.
func (m *TenantMemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TenantMemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TenantMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *TenantMemberMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *TenantMemberMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the TenantMember entity.
// If the TenantMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMemberMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *TenantMemberMutation) ResetRoleID() {
	m.role = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TenantMemberMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[tenantmember.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TenantMemberMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TenantMemberMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TenantMemberMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TenantMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[tenantmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TenantMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TenantMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TenantMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *TenantMemberMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[tenantmember.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *TenantMemberMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *TenantMemberMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *TenantMemberMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the TenantMemberMutation builder.
func (m *TenantMemberMutation) Where(ps ...predicate.TenantMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantMember).
func (m *TenantMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMemberMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, tenantmember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantmember.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tenantmember.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, tenantmember.FieldDeletedBy)
	}
	if m.tenant != nil {
		fields = append(fields, tenantmember.FieldTenantID)
	}
	if m.user != nil {
		fields = append(fields, tenantmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, tenantmember.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantmember.FieldCreatedAt:
		return m.CreatedAt()
	case tenantmember.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantmember.FieldDeletedAt:
		return m.DeletedAt()
	case tenantmember.FieldDeletedBy:
		return m.DeletedBy()
	case tenantmember.FieldTenantID:
		return m.TenantID()
	case tenantmember.FieldUserID:
		return m.UserID()
	case tenantmember.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantmember.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tenantmember.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tenantmember.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantmember.FieldUserID:
		return m.OldUserID(ctx)
	case tenantmember.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown TenantMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantmember.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tenantmember.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tenantmember.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantmember.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tenantmember.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown TenantMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMemberMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, tenantmember.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenantmember.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenantmember.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown TenantMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantmember.FieldDeletedAt) {
		fields = append(fields, tenantmember.FieldDeletedAt)
	}
	if m.FieldCleared(tenantmember.FieldDeletedBy) {
		fields = append(fields, tenantmember.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMemberMutation) ClearField(name string) error {
	switch name {
	case tenantmember.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tenantmember.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown TenantMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMemberMutation) ResetField(name string) error {
	switch name {
	case tenantmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantmember.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tenantmember.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tenantmember.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantmember.FieldUserID:
		m.ResetUserID()
		return nil
	case tenantmember.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown TenantMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, tenantmember.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, tenantmember.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, tenantmember.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenantmember.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case tenantmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tenantmember.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, tenantmember.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, tenantmember.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, tenantmember.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case tenantmember.EdgeTenant:
		return m.clearedtenant
	case tenantmember.EdgeUser:
		return m.cleareduser
	case tenantmember.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMemberMutation) ClearEdge(name string) error {
	switch name {
	case tenantmember.EdgeTenant:
		m.ClearTenant()
		return nil
	case tenantmember.EdgeUser:
		m.ClearUser()
		return nil
	case tenantmember.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown TenantMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMemberMutation) ResetEdge(name string) error {
	switch name {
	case tenantmember.EdgeTenant:
		m.ResetTenant()
		return nil
	case tenantmember.EdgeUser:
		m.ResetUser()
		return nil
	case tenantmember.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown TenantMember edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	deleted_by                  *int
	adddeleted_by               *int
	username                    *string
	is_admin                    *bool
	clearedFields               map[string]struct{}
	tenant_members              map[int]struct{}
	removedtenant_members       map[int]struct{}
	clearedtenant_members       bool
	credentials                 map[int]struct{}
	removedcredentials          map[int]struct{}
	clearedcredentials          bool
	attributes                  map[int]struct{}
	removedattributes           map[int]struct{}
	clearedattributes           bool
	federated_identities        map[int]struct{}
	removedfederated_identities map[int]struct{}
	clearedfederated_identities bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// AddTenantMemberIDs adds the "tenant_members" edge to the TenantMember entity by ids.
func (m *UserMutation) AddTenantMemberIDs(ids ...int) {
	if m.tenant_members == nil {
		m.tenant_members = make(map[int]struct{})
	}
	for i := range ids {
		m.tenant_members[ids[i]] = struct{}{}
	}
}

// ClearTenantMembers clears the "tenant_members" edge to the TenantMember entity.
func (m *UserMutation) ClearTenantMembers() {
	m.clearedtenant_members = true
}

// TenantMembersCleared reports if the "tenant_members" edge to the TenantMember entity was cleared.
func (m *UserMutation) TenantMembersCleared() bool {
	return m.clearedtenant_members
}

// RemoveTenantMemberIDs removes the "tenant_members" edge to the TenantMember entity by IDs.
func (m *UserMutation) RemoveTenantMemberIDs(ids ...int) {
	if m.removedtenant_members == nil {
		m.removedtenant_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tenant_members, ids[i])
		m.removedtenant_members[ids[i]] = struct{}{}
	}
}

// RemovedTenantMembers returns the removed IDs of the "tenant_members" edge to the TenantMember entity.
func (m *UserMutation) RemovedTenantMembersIDs() (ids []int) {
	for id := range m.removedtenant_members {
		ids = append(ids, id)
	}
	return
}

// TenantMembersIDs returns the "tenant_members" edge IDs in the mutation.
func (m *UserMutation) TenantMembersIDs() (ids []int) {
	for id := range m.tenant_members {
		ids = append(ids, id)
	}
	return
}

// ResetTenantMembers resets all changes to the "tenant_members" edge.
func (m *UserMutation) ResetTenantMembers() {
	m.tenant_members = nil
	m.clearedtenant_members = false
	m.removedtenant_members = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *UserMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *UserMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *UserMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *UserMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *UserMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *UserMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *UserMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddAttributeIDs adds the "attributes" edge to the UserAttributeValue entity by ids.
func (m *UserMutation) AddAttributeIDs(ids ...int) {
	if m.attributes == nil {
		m.attributes = make(map[int]struct{})
	}
	for i := range ids {
		m.attributes[ids[i]] = struct{}{}
	}
}

// ClearAttributes clears the "attributes" edge to the UserAttributeValue entity.
func (m *UserMutation) ClearAttributes() {
	m.clearedattributes = true
}

// AttributesCleared reports if the "attributes" edge to the UserAttributeValue entity was cleared.
func (m *UserMutation) AttributesCleared() bool {
	return m.clearedattributes
}

// RemoveAttributeIDs removes the "attributes" edge to the UserAttributeValue entity by IDs.
func (m *UserMutation) RemoveAttributeIDs(ids ...int) {
	if m.removedattributes == nil {
		m.removedattributes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attributes, ids[i])
		m.removedattributes[ids[i]] = struct{}{}
	}
}

// RemovedAttributes returns the removed IDs of the "attributes" edge to the UserAttributeValue entity.
func (m *UserMutation) RemovedAttributesIDs() (ids []int) {
	for id := range m.removedattributes {
		ids = append(ids, id)
	}
	return
}

// AttributesIDs returns the "attributes" edge IDs in the mutation.
func (m *UserMutation) AttributesIDs() (ids []int) {
	for id := range m.attributes {
		ids = append(ids, id)
	}
	return
}

// ResetAttributes resets all changes to the "attributes" edge.
func (m *UserMutation) ResetAttributes() {
	m.attributes = nil
	m.clearedattributes = false
	m.removedattributes = nil
}

// AddFederatedIdentityIDs adds the "federated_identities" edge to the FederatedIdentity entity by ids.
func (m *UserMutation) AddFederatedIdentityIDs(ids ...int) {
	if m.federated_identities == nil {
		m.federated_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.federated_identities[ids[i]] = struct{}{}
	}
}

// ClearFederatedIdentities clears the "federated_identities" edge to the FederatedIdentity entity.
func (m *UserMutation) ClearFederatedIdentities() {
	m.clearedfederated_identities = true
}

// FederatedIdentitiesCleared reports if the "federated_identities" edge to the FederatedIdentity entity was cleared.
func (m *UserMutation) FederatedIdentitiesCleared() bool {
	return m.clearedfederated_identities
}

// RemoveFederatedIdentityIDs removes the "federated_identities" edge to the FederatedIdentity entity by IDs.
func (m *UserMutation) RemoveFederatedIdentityIDs(ids ...int) {
	if m.removedfederated_identities == nil {
		m.removedfederated_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.federated_identities, ids[i])
		m.removedfederated_identities[ids[i]] = struct{}{}
	}
}

// RemovedFederatedIdentities returns the removed IDs of the "federated_identities" edge to the FederatedIdentity entity.
func (m *UserMutation) RemovedFederatedIdentitiesIDs() (ids []int) {
	for id := range m.removedfederated_identities {
		ids = append(ids, id)
	}
	return
}

// FederatedIdentitiesIDs returns the "federated_identities" edge IDs in the mutation.
func (m *UserMutation) FederatedIdentitiesIDs() (ids []int) {
	for id := range m.federated_identities {
		ids = append(ids, id)
	}
	return
}

// ResetFederatedIdentities resets all changes to the "federated_identities" edge.
func (m *UserMutation) ResetFederatedIdentities() {
	m.federated_identities = nil
	m.clearedfederated_identities = false
	m.removedfederated_identities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldUsername:
		return m.Username()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant_members != nil {
		edges = append(edges, user.EdgeTenantMembers)
	}
	if m.credentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.attributes != nil {
		edges = append(edges, user.EdgeAttributes)
	}
	if m.federated_identities != nil {
		edges = append(edges, user.EdgeFederatedIdentities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.tenant_members))
		for id := range m.tenant_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.attributes))
		for id := range m.attributes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFederatedIdentities:
		ids := make([]ent.Value, 0, len(m.federated_identities))
		for id := range m.federated_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtenant_members != nil {
		edges = append(edges, user.EdgeTenantMembers)
	}
	if m.removedcredentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.removedattributes != nil {
		edges = append(edges, user.EdgeAttributes)
	}
	if m.removedfederated_identities != nil {
		edges = append(edges, user.EdgeFederatedIdentities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenantMembers:
		ids := make([]ent.Value, 0, len(m.removedtenant_members))
		for id := range m.removedtenant_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.removedattributes))
		for id := range m.removedattributes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFederatedIdentities:
		ids := make([]ent.Value, 0, len(m.removedfederated_identities))
		for id := range m.removedfederated_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant_members {
		edges = append(edges, user.EdgeTenantMembers)
	}
	if m.clearedcredentials {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.clearedattributes {
		edges = append(edges, user.EdgeAttributes)
	}
	if m.clearedfederated_identities {
		edges = append(edges, user.EdgeFederatedIdentities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenantMembers:
		return m.clearedtenant_members
	case user.EdgeCredentials:
		return m.clearedcredentials
	case user.EdgeAttributes:
		return m.clearedattributes
	case user.EdgeFederatedIdentities:
		return m.clearedfederated_identities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenantMembers:
		m.ResetTenantMembers()
		return nil
	case user.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case user.EdgeAttributes:
		m.ResetAttributes()
		return nil
	case user.EdgeFederatedIdentities:
		m.ResetFederatedIdentities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAttributeValueMutation represents an operation that mutates the UserAttributeValue nodes in the graph.
type UserAttributeValueMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	deleted_by        *int
	adddeleted_by     *int
	value             *string
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	definition        *int
	cleareddefinition bool
	done              bool
	oldValue          func(context.Context) (*UserAttributeValue, error)
	predicates        []predicate.UserAttributeValue
}

var _ ent.Mutation = (*UserAttributeValueMutation)(nil)

// userattributevalueOption allows management of the mutation configuration using functional options.
type userattributevalueOption func(*UserAttributeValueMutation)

// newUserAttributeValueMutation creates new mutation for the UserAttributeValue entity.
func newUserAttributeValueMutation(c config, op Op, opts ...userattributevalueOption) *UserAttributeValueMutation {
	m := &UserAttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAttributeValueID sets the ID field of the mutation.
func withUserAttributeValueID(id int) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAttributeValue
		)
		m.oldValue = func(ctx context.Context) (*UserAttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAttributeValue sets the old UserAttributeValue of the mutation.
func withUserAttributeValue(node *UserAttributeValue) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		m.oldValue = func(context.Context) (*UserAttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generate: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAttributeValueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAttributeValueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAttributeValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAttributeValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAttributeValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAttributeValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAttributeValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAttributeValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAttributeValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserAttributeValueMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserAttributeValueMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserAttributeValueMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userattributevalue.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserAttributeValueMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userattributevalue.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserAttributeValueMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userattributevalue.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserAttributeValueMutation) SetDeletedBy(i int) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserAttributeValueMutation) DeletedBy() (r int, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldDeletedBy(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserAttributeValueMutation) AddDeletedBy(i int) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserAttributeValueMutation) AddedDeletedBy() (r int, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserAttributeValueMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[userattributevalue.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserAttributeValueMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userattributevalue.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserAttributeValueMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, userattributevalue.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *UserAttributeValueMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAttributeValueMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAttributeValueMutation) ResetUserID() {
	m.user = nil
}

// SetAttributeID sets the "attribute_id" field.
func (m *UserAttributeValueMutation) SetAttributeID(i int) {
	m.definition = &i
}

// AttributeID returns the value of the "attribute_id" field in the mutation.
func (m *UserAttributeValueMutation) AttributeID() (r int, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeID returns the old "attribute_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldAttributeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeID: %w", err)
	}
	return oldValue.AttributeID, nil
}

// ResetAttributeID resets all changes to the "attribute_id" field.
func (m *UserAttributeValueMutation) ResetAttributeID() {
	m.definition = nil
}

// SetValue sets the "value" field.
func (m *UserAttributeValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *UserAttributeValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *UserAttributeValueMutation) ResetValue() {
	m.value = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAttributeValueMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userattributevalue.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAttributeValueMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAttributeValueMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDefinitionID sets the "definition" edge to the AttributeDefinition entity by id.
func (m *UserAttributeValueMutation) SetDefinitionID(id int) {
	m.definition = &id
}

// ClearDefinition clears the "definition" edge to the AttributeDefinition entity.
func (m *UserAttributeValueMutation) ClearDefinition() {
	m.cleareddefinition = true
	m.clearedFields[userattributevalue.FieldAttributeID] = struct{}{}
}

// DefinitionCleared reports if the "definition" edge to the AttributeDefinition entity was cleared.
func (m *UserAttributeValueMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the "definition" edge ID in the mutation.
func (m *UserAttributeValueMutation) DefinitionID() (id int, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the "definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) DefinitionIDs() (ids []int) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition resets all changes to the "definition" edge.
func (m *UserAttributeValueMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// Where appends a list predicates to the UserAttributeValueMutation builder.
func (m *UserAttributeValueMutation) Where(ps ...predicate.UserAttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAttributeValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAttributeValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAttributeValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAttributeValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAttributeValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAttributeValue).
func (m *UserAttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userattributevalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userattributevalue.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userattributevalue.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userattributevalue.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, userattributevalue.FieldUserID)
	}
	if m.definition != nil {
		fields = append(fields, userattributevalue.FieldAttributeID)
	}
	if m.value != nil {
		fields = append(fields, userattributevalue.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.CreatedAt()
	case userattributevalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case userattributevalue.FieldDeletedAt:
		return m.DeletedAt()
	case userattributevalue.FieldDeletedBy:
		return m.DeletedBy()
	case userattributevalue.FieldUserID:
		return m.UserID()
	case userattributevalue.FieldAttributeID:
		return m.AttributeID()
	case userattributevalue.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userattributevalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userattributevalue.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userattributevalue.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userattributevalue.FieldUserID:
		return m.OldUserID(ctx)
	case userattributevalue.FieldAttributeID:
		return m.OldAttributeID(ctx)
	case userattributevalue.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userattributevalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userattributevalue.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userattributevalue.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userattributevalue.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userattributevalue.FieldAttributeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeID(v)
		return nil
	case userattributevalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAttributeValueMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, userattributevalue.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userattributevalue.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userattributevalue.FieldDeletedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAttributeValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userattributevalue.FieldDeletedAt) {
		fields = append(fields, userattributevalue.FieldDeletedAt)
	}
	if m.FieldCleared(userattributevalue.FieldDeletedBy) {
		fields = append(fields, userattributevalue.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ClearField(name string) error {
	switch name {
	case userattributevalue.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userattributevalue.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ResetField(name string) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userattributevalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userattributevalue.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userattributevalue.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userattributevalue.FieldUserID:
		m.ResetUserID()
		return nil
	case userattributevalue.FieldAttributeID:
		m.ResetAttributeID()
		return nil
	case userattributevalue.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.definition != nil {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userattributevalue.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userattributevalue.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAttributeValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.cleareddefinition {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case userattributevalue.EdgeUser:
		return m.cleareduser
	case userattributevalue.EdgeDefinition:
		return m.cleareddefinition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ClearUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ClearDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ResetUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue edge %s", name)
}
